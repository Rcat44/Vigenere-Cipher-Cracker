/*
 * Reese Myers
 * CPSC 1070: 010
 * 04/09/2023 */

// Purpose: This file defines all of the functions for the CipherAdvanced class.
// The CipherAdvanced class is used to decrypt messages that have been encrypted
// with Vigen√®re ciphers of length 1-5. The class is able to generate all the possible
// plaintexts of a ciphertext message by generating all possible keys and comparing
// all mesaages encrypted with these keys to a dictionary file.

#include "CipherAdvanced.h"
#include <fstream>
#include <vector>
#include <iostream>
#include <cctype> // for isalpha()
#include <algorithm> // https://cplusplus.com/reference/algorithm/sort/
#include <unordered_set> // https://cplusplus.com/reference/unordered_set/unordered_set/

// The default constructor for the CipherAdvanced derived class does not contain any code.
// This constuctor specifies use of the Cipher constructor that takes in a single boolean value
CipherAdvanced::CipherAdvanced() : Cipher(true) {}

// The destructor for the CipherAdvanced derived class does not contain any code.
CipherAdvanced::~CipherAdvanced(){}

// This function performs all the necessary operations to decrypt a word when the key is not already known.
// The function reads in from a dictionary file and generates all possible key combinations.
// All words genrated from these keys are compared to the words from the dictionary file.
// If a match is found, it is printed out.
// The function does not return anything.
void CipherAdvanced::unknownScramble(string word) {

	ifstream inFile("/usr/share/dict/words"); // Opens Linux words file
	unordered_set<string> dictionary; // Declares an unordered set of strings
	
	// Sets the bucket count to be the most appopriate for 100,000 elements (slightly more than total words in dictionary file).
	// https://cplusplus.com/reference/unordered_set/unordered_set/reserve/
	dictionary.reserve(100000);

	string tempDictWord;
	int stringSize = word.size(); // Sets stringSize to the size of the word parameter

	// This while loop reads in each word in the words file one at a time.
	// If the size of a word that is read in is equal to stringSize and all of the characters in the word are alphabetic,
	// the word is inserted into dictionary.
	// https://cplusplus.com/reference/algorithm/all_of/
	while (inFile >> tempDictWord) {
		if ((static_cast<int>(tempDictWord.size()) == stringSize) && (all_of(tempDictWord.begin(), tempDictWord.end(), [](char& c) { return isalpha(c); }))) {
			if (isupper(tempDictWord[0])) {
				tempDictWord[0] = tolower(tempDictWord[0]);
			}
			dictionary.insert(tempDictWord);
		}
	}
	inFile.close();
	
	// A vector is created for strings that match words in the dictionary.
	// Space is reserved in advance for 100 elements.
	vector<string> matches;
	matches.reserve(100);

	string tempWord;
        int shift1, shift2, shift3, shift4, shift5, keyLength, wordIndex;

	keyLength = 3;
	tempWord = word; // Assigns word to tempWord

	// The next three sets of nested for loops are used to genrate all posible plaintexts and compare them
	// to the dictionary. This set of nested for loops generates all possible words that could have been
	// encrypted by a key length of 3. The next set is responsible for a key length of 4, and the third set
	// is resposible for a key of length 5 (Length 2 keys can be generated by equivalent length 4 keys, and
	// length 1 keys can be generated by equivalent length 3,4, or 5 keys). Each of these three sets of nested
	// for loops operates under the same set of rules.
	//
	// Rule 1.1: Each loop that updates a shift contains another loop that updates tempWord.
	//
	// Rule 2.1: In any loop that updates tempWord, the starting wordIndex is the # of the shift - 1.
	// 	     For example, the shift1 starts at wordIndex 0, shift2 starts at 1, etc.
	//
	// Rule 3.1: The character at tempWord[wordIndex] is shifted by shift# (shift1, shift2, etc.) thorugh assignment
	//           while having letter rollover accounted for.
	//
	// Rule 3.2: Until the end of tempWord is reached, each letter of the word that is keyLength# of characters away
	// 	     in the string is also shifted.
	//
	// Rule 4.1: Each loop that contains a loop that updates tempWord may also contain a loop for another shift if required.
	// 	     For example, in this case, the shift1 loop contains a shift2 loop and the shift2 loop contains a shift3 loop.
	//
	// Rule 4.2: The only loop that updates tempWord that does not contain a loop for another shift is the loop for the final shift
	//           For example, in the first set, the loop for the final shift is loop 3. 
	//           
	// Rule 4.3: Each final shift loop contains an if statement that checks dictionary for the tempWord resulting from all shifts. 
	//           If a match is found, then tempWord is added to the matches vector. https://cplusplus.com/reference/algorithm/find/

	for (shift1 = 0; shift1 < 26; shift1++) {
		for (wordIndex = 0; wordIndex < stringSize; wordIndex += keyLength) {
                                tempWord[wordIndex] = (((word[wordIndex] - 97) + shift1) % 26) + 97;
		}
		for (shift2 = 0; shift2 < 26; shift2++) {
			for (wordIndex = 1; wordIndex < stringSize; wordIndex += keyLength) {
				tempWord[wordIndex] = (((word[wordIndex] - 97) + shift2) % 26) + 97;
			}
			for (shift3 = 0; shift3 < 26; shift3++) {
				for (wordIndex = 2; wordIndex < stringSize; wordIndex += keyLength) {
					tempWord[wordIndex] = (((word[wordIndex] - 97) + shift3) % 26) + 97;
				}
				if (dictionary.find(tempWord) != dictionary.end()) {
                                	matches.push_back(tempWord);
				}
			}
		}
	}
	
	keyLength = 4;
	tempWord = word;

	// Uses same rules as before but this time for a key length of 4.
	for (shift1 = 0; shift1 < 26; shift1++) {
		for (wordIndex = 0; wordIndex < stringSize; wordIndex += keyLength) {
			tempWord[wordIndex] = (((word[wordIndex] - 97) + shift1) % 26) + 97;
		}
		for (shift2 = 0; shift2 < 26; shift2++) {
			for (wordIndex = 1; wordIndex < stringSize; wordIndex += keyLength) {
				tempWord[wordIndex] = (((word[wordIndex] - 97) + shift2) % 26) + 97;
			}
			for (shift3 = 0; shift3 < 26; shift3++) {
				for (wordIndex = 2; wordIndex < stringSize; wordIndex += keyLength) {
					tempWord[wordIndex] = (((word[wordIndex] - 97) + shift3) % 26) + 97;
				}
				for (shift4 = 0; shift4 < 26; shift4++) {
					for (wordIndex = 3; wordIndex < stringSize; wordIndex += keyLength) {
						tempWord[wordIndex] = (((word[wordIndex] - 97) + shift4) % 26) + 97;
					}
					if (dictionary.find(tempWord) != dictionary.end()) {
						matches.push_back(tempWord);
					}
				}
			}
		}
	}

	keyLength = 5;
	tempWord = word;

	// Uses same rules as before but this time for a key length of 5.
	for (shift1 = 0; shift1 < 26; shift1++) {
		for (wordIndex = 0; wordIndex < stringSize; wordIndex += keyLength) {
			tempWord[wordIndex] = (((word[wordIndex] - 97) + shift1) % 26) + 97;
		}
		for (shift2 = 0; shift2 < 26; shift2++) {
			for (wordIndex = 1; wordIndex < stringSize; wordIndex += keyLength) {
				tempWord[wordIndex] = (((word[wordIndex] - 97) + shift2) % 26) + 97;
			}
			for (shift3 = 0; shift3 < 26; shift3++) {
				for (wordIndex = 2; wordIndex < stringSize; wordIndex += keyLength) {
					tempWord[wordIndex] = (((word[wordIndex] - 97) + shift3) % 26) + 97;
				}
				for (shift4 = 0; shift4 < 26; shift4++) {
					for (wordIndex = 3; wordIndex < stringSize; wordIndex += keyLength) {
						tempWord[wordIndex] = (((word[wordIndex] - 97) + shift4) % 26) + 97;
					}
					for (shift5 = 0; shift5 < 26; shift5++) {
						for (wordIndex = 4; wordIndex < stringSize; wordIndex += keyLength) {
							tempWord[wordIndex] = (((word[wordIndex] - 97) + shift5) % 26) + 97;
						}
						if (dictionary.find(tempWord) != dictionary.end()) {
                                                	matches.push_back(tempWord);
						}
					}
				}
			}
		}
	}
	
	// The vector of matches is sorted based on alphabetical order.
	//https://cplusplus.com/reference/algorithm/sort/
	sort(matches.begin(), matches.end(), [](string& s1, string& s2) {
			return s1 < s2;});

	int matchSize = matches.size() - 1; // One less than the size of the matches vector is assigned to matchSize.
	
	// This for loop iterates while i is less than matchSize times.
	// On eacteration if the string at matches[i] matches the one at matches[i+1],
	// element i+1 is erased from the vector, and matchSize is decremented.
	// Otherwise i is incremented.
	for (int i = 0; i < matchSize;) {
		if (matches[i] == matches[i+1]) {
			matches.erase(matches.begin()+i);
			matchSize--;
		}
		else {
			i++;
		}
	}

	matchSize = matches.size(); // The size of the matches vector is assigned to matchSize
	
	// If matchSize is greater than zero, each string contained in the vector is printed out.
	// Otherwise, prints out a message stating that no possible messages exist.
	if (matchSize > 0) {
		for (int i = 0; i < matchSize; i++) {
			cout << matches[i] << endl;
		}
	}
	else {
		cout << "NO POSSIBILITIES EXIST\n";
	}
}
